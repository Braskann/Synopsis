# 1. Типы данных

## 1.1 Числа
* int - целые числа
* float - числа с плавающей запятой
* complex - комплексные числа относятся

**Функции** 
* `type()` - узнать класс переменной или значения
* `isinstance()` - проверка принадлежности объекта определённому классу

```python
>>> a = 5
>>> print(a, "is of type", type(a))
5 is of type <class 'int'>
>>> a = 2.0
>>> print(a, "is of type", type(a))
2.0 is of type <class 'float'>
>>> a = 1+2j
>>> print(a, "is complex number?", isinstance(1+2j, complex))
(1+2j) is complex number? True
```
## 1.2 Строки / Str
Строка представляет собой последовательность символов. Строки в Python относятся к категории неизменяемых последовательностей. Многострочные строки можно обозначить тройными кавычками `'''`
```python
>>> s = "Простая строка"
>>> s = '''многострочная
строка'''
```
## 1.3 Списки / List
Список представляет собой упорядоченную последовательность элементов. Объявление списка:
```python
>>> a = [1, 2.2, 'python']
```
### Взятие элемента по индексу
Python поддерживает отрицательные индексы
```python
>>> a = [1, 3, 8, 7]
>>> a[-1]
7
```
### Срезы
item[START:STOP:STEP] - берёт срез от номера START, до STOP (не включая его), с шагом STEP. По умолчанию START = 0, STOP = длине объекта, STEP = 1
```python
>>> a = [1, 3, 8, 7]
>>> a[:]            
[1, 3, 8, 7]
>>> a[-2::-1]       
[8, 3, 1]
>>> a[::2]          
[1, 8]
```
С помощью срезов можно добавлять и удалять элементы
```python
my_list = [1, 2, 3, 4, 5]
my_list[:2] = []    # или del my_list[:2]
print(my_list)      # [3, 4, 5]
```
```python
my_list = [1, 2, 3, 4, 5]
my_list[1:3] = [20, 30]
print(my_list)          # [1, 20, 30, 4, 5]
```
аналоги .append() и insert()
```python
my_list = [1, 2, 3, 4, 5]
my_list[5:] = [6]      # вставляем в конец — .append(6)
print(my_list)         # [1, 2, 3, 4, 5, 6]
my_list[0:0] = [0]     # вставляем в начало — .insert(0, 0)
print(my_list)         # [0, 1, 2, 3, 4, 5, 6]
my_list[3:3] = [25]    # вставляем между элементами — .insert(3, 25)
print(my_list)         # [0, 1, 2, 25, 3, 4, 5, 6]
```
## 1.4 Кортежи / Tuple
Кортеж - упорядоченная неизменяемая последовательность элементов. Для извлечения элементов используется оператор среза `[]`
```python
>>> t = (5,'program', 1+3j)
>>> print("t[1] =", t[1])    
t[1] = program
```
## 1.5 Множества / Set
Множество - неупорядоченная уникализированная последовательность. Над множествами можно выполнять операции объединения, пересечения, добавления, разности. Оператор среза не работает
```python
>>> a = {1,2,2,3,3,3}
>>> a
{1, 2, 3}
```
## 1.6 Словари / Dict
Словари — неупорядоченные наборы пар ключ-значение. Ключом может являться в принципе любой неизменяемый тип данных
```python
gender_dict = {0: 'муж',
               1: 'жен'}
```

## 1.7 Bool
Логический тип данных, который может содержать значения `True` или `False`
## 1.8 None
Этот тип используется для обозначения отсутствия значения
# 2. Работа с файлами
Файл – это именованная область диска, предназначенная для длительного хранения данных в постоянной памяти
## Открытие open()
``` python
>>> f = open("test.txt")    # открыть файл в текущей папке
>>> f = open("C:/Python33/README.txt")  # указание полного пути
```
* ‘r’- для чтения
* ’w’  — для перезаписи
* ’a’ — для изменения
* ‘x’ - открытие для записи
``` python
f = open("test.txt")      # эквивалент 'r' или 'rt'
f = open("test.txt",'w')  # запись в текстовом режиме
f = open("img.bmp",'r+b') # чтение и запись в бинарном формате
```
## Закрытие close()
```python
f = open("test.txt",encoding = 'utf-8')
# выполнение операций с файлом
f.close()
```
Закрытие файла с блоком `try - finally`, предусматривающее исключения:
```python
try:
   f = open("test.txt",encoding = 'utf-8')
   # выполнение операций с файлом
finally:
   f.close() 
```
Конструкция `with`, файл будет закрыт при выходе из конструкции:
```python
with open("test.txt",encoding = 'utf-8') as f:
   # выполнение операций с файлом
```
## Запись строки write()
Возвращает количество символов, записанных в файл
```python
with open("test.txt",'w',encoding = 'utf-8') as f:
   f.write("my first filen")
   f.write("This filenn")
   f.write("contains three linesn"
```
## Чтение read() seek() tell() readline() readlines()
read() - чтение данных в указанном количестве
```python
>>> f = open("test.txt",'r',encoding = 'utf-8')
>>> f.read(4)    # чтение первых 4 символов
'This'
 
>>> f.read(4)    # чтение следующих 4 символов
' is '
 
>>> f.read()     # чтение остальных данных до конца файла
'my first file This file contains three linesn'
```
tell() - возвращение позиции курсора в виде к-ва байтов
seek() - изменение текущей позиции курсора
readline() - извлечение отдельной строки, читает файл до символа новой стр
readlines() возвращает список оставшихся строк
```python
>>> f.tell()    # получаем текущую позицию курсора в файле
56
 
>>> f.seek(0)   # возвращаем курсор в начальную позицию
0
 
>>> print(f.read())  # читаем весь файл
This is my first file
This file
contains three lines

>>> f.readlines()
['This is my first filen', 'This filen', 'contains three linesn']
```
 При работе с файлами в текстовом формате рекомендуется указывать тип кодировки
 ```python
f = open("test.txt",mode = 'r',encoding = 'utf-8'  
```

# 2. Объектно-ориентированное программирование
Программы состоящие из функций, т.е. блоков выражений, которые манипулируют данными - процедурно-ориентированный стиль программирования. Существует и другой способ организации программ: объединять данные и функционал внутри некоего объекта. Это называется объектно-ориентированной парадигмой программирования

Два основных аспекта объектно-ориентированного программирования – `классы` и `объекты`. Класс создаёт новый тип, а объекты являются экземплярами класса

Объекты могут хранить данные в обычных переменных, которые принадлежат объекту. Переменные, принадлежащие объекту или классу, называют `полями`. Объекты могут
также обладать `функционалом`, т.е. иметь функции, принадлежащие классу. Такие функции принято называть `методами класса`. Всё вместе (поля и методы) принято называть `атрибутами класса`. Поля бывают двух типов: они могут принадлежать каждому отдельному экземпляру объекта класса или всему классу
## Параметр/переменная self
Предположим, у нас есть класс с именем MyClass и экземпляр этого класса с именем myobject. При вызове метода этого объекта, например, “myobject.method(arg1, arg2)”, Python автоматически превращает это в “MyClass.method(myobject, arg1, arg2)” – в этом и состоит смысл self.

 ## Метод __init__
 Метод __init__ запускается, как только объект класса реализуется. Этот метод полезен для осуществления разного рода инициализации, необходимой для данного объекта. Обратите внимание на двойные подчёркивания в начале и в конце имени
 
 ## Инкапсуляция
 ## Декораторы
 Декоратор - функция, которая принимает другую функцию в качестве аргумента. Декорированная функция может иметь небольшие отличия в виде дополнительных функций совмещенных с базовым определением
 ```python
 @staticmethod #функция внутри класса, применяется в тех случаях, когда есть функция, которая имеет связь с классом
 @classmethod #вызывается при помощи экземпляра класса или напрямую через класс
 ```
 
 # 3. Обработка исключений
 ## try..except
 При этом все обычные команды помещаются внутрь try-блока, а все обработчики исключений – в except-блок.
```python
try:
text = input('Введите что-нибудь --> ')
except EOFError:
print('Ну зачем вы сделали мне EOF?')
except KeyboardInterrupt:
print('Вы отменили операцию.')
else:
print('Вы ввели {0}'.format(text))
```
Выражение except может обрабатывать как одиночную ошибку или исключение, так и список ошибок/исключений в скобках. Если не указано имя ошибки или исключения,
обрабатываться будут *все* ошибки и исключения.

##  Вызов исключения
Исключение можно поднять при помощи оператора raise2, передав ему имя ошибки/исключения, а также объект исключения, который нужно выбросить.
Вызываемая ошибка или исключение должна быть классом, который прямо или непрямо
является производным от класса Exception.
```python
class ShortInputException(Exception):
'''Пользовательский класс исключения.'''
def __init__(self, length, atleast):
Exception.__init__(self)
self.length = length
self.atleast = atleast
try:
text = input('Введите что-нибудь --> ')
if len(text) < 3:
raise ShortInputException(len(text), 3)
# Здесь может происходить обычная работа
except EOFError:
print('Ну зачем вы сделали мне EOF?')
except ShortInputException as ex:
print('ShortInputException: Длина введённой строки -- {0}; \
ожидалось, как минимум, {1}'.format(ex.length, ex.atleast))
else:
print('Не было исключений.')
```
```python
Вывод:
$ python3 raising.py
Введите что-нибудь --> а
ShortInputException: Длина введённой строки -- 1; ожидалось, как минимум, 3

